<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIã‚¹ã‚¯ãƒ¼ãƒ« TODOã‚¢ãƒ—ãƒª</title>
    <!-- Tailwind CSS CDNã‚’èª­ã¿è¾¼ã¿ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã¨ã—ã¦Interã‚’è¨­å®š */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f8f8; /* èƒŒæ™¯è‰²ã‚’è–„ã„ã‚°ãƒ¬ãƒ¼ã«è¨­å®š */
            color: #333; /* ãƒ†ã‚­ã‚¹ãƒˆè‰²ã‚’æ¿ƒã„ã‚°ãƒ¬ãƒ¼ã«è¨­å®š */
        }
        
        /* AIã‚¹ã‚¯ãƒ¼ãƒ«ãƒ­ã‚´ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .logo {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            font-weight: 700;
            text-shadow: none;
        }
        
        .logo-icon {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 8px;
            color: white;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }
        
        /* å®Œäº†æ¸ˆã¿ã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚­ã‚¹ãƒˆã«æ‰“ã¡æ¶ˆã—ç·šã¨è‰²ã‚’è¨­å®š */
        .task-item.completed .task-text {
            text-decoration: line-through;
            color: #a0a0a0; /* å®Œäº†æ¸ˆã¿ã‚¿ã‚¹ã‚¯ã¯ã‚ˆã‚Šè–„ã„ã‚°ãƒ¬ãƒ¼ã« */
        }
        
        /* ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸå·¦ãƒ‘ãƒ‡ã‚£ãƒ³ã‚° */
        .indent-0 { padding-left: 0.5rem; } /* ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¨ãƒ†ã‚­ã‚¹ãƒˆã®é–“ã®ã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ */
        .indent-1 { padding-left: 2.5rem; }
        .indent-2 { padding-left: 4.5rem; }
        .indent-3 { padding-left: 6.5rem; }
        .indent-4 { padding-left: 8.5rem; }
        
        /* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #a0a0a0;
            background-color: #f0f0f0;
        }
        
        /* ã‚«ã‚¹ã‚¿ãƒ ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’èª¿æ•´ */
        .form-checkbox {
            border-width: 2px; /* å°‘ã—å¤ªã‚ã®å¢ƒç•Œç·šã§å­˜åœ¨æ„Ÿã‚’å‡ºã™ */
        }
        
        /* ãƒ›ãƒãƒ¼åŠ¹æœ */
        .task-item:hover {
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        /* ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¹ã‚¿ã‚¤ãƒ« */
        .task-text:focus {
            outline: none;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            padding: 2px 4px;
        }

        /* ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚¹ã‚¿ã‚¤ãƒ« - ã‚¿ã‚¹ã‚¯ã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ã«é©ç”¨ */
        .task-item.indent-0 { margin-left: 0 !important; }
        .task-item.indent-1 { margin-left: 1rem !important; }
        .task-item.indent-2 { margin-left: 2rem !important; }
        .task-item.indent-3 { margin-left: 3rem !important; }
        .task-item.indent-4 { margin-left: 4rem !important; }

        /* è¦ªå­é–¢ä¿‚ã‚’ç¤ºã™æ¥ç¶šç·š */
        .task-item[class*="indent-"]:not(.indent-0) {
            position: relative;
        }

        /* ä¸¸ã„ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ« */
        .custom-checkbox {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid #d1d5db;
            border-radius: 50%;
            background-color: white;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .custom-checkbox:hover {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .custom-checkbox:checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .custom-checkbox:checked::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .custom-checkbox:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }

        /* å®Œäº†æ¸ˆã¿ã‚¿ã‚¹ã‚¯ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .task-completed {
            opacity: 0.6;
        }

        .task-completed .task-text {
            text-decoration: line-through;
            color: #6b7280;
        }

        /* ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚¹ã‚¿ã‚¤ãƒ« */
        .task-item.indent-1 {
            padding-left: 2rem;
        }

        .task-item.indent-2 {
            padding-left: 4rem;
        }

        .task-item.indent-3 {
            padding-left: 6rem;
        }

        .task-item.indent-4 {
            padding-left: 8rem;
        }

        /* ç´™å¹é›ªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes confetti-fall {
            0% {
                transform: translateY(-10px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠ: ä¸­å¤®å¯„ã›ã€æœ€å¤§å¹…è¨­å®šã€ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è¿½åŠ  -->
    <div class="container mx-auto p-4 flex-grow max-w-2xl">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼éƒ¨åˆ† -->
        <header class="text-center mb-8 relative">
            <!-- ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ -->
            <div class="absolute top-0 right-0 flex space-x-2">
                <!-- ãƒ­ã‚°ã‚¢ã‚¦ãƒˆãƒœã‚¿ãƒ³ -->
                <a href="/logout" class="bg-gray-100 hover:bg-gray-200 text-gray-600 px-3 py-2 rounded-lg text-sm transition-colors">
                    ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
                </a>
                <!-- ç®¡ç†è€…ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ï¼ˆç®¡ç†è€…ã®ã¿è¡¨ç¤ºï¼‰ -->
                {% if session.username == 'admin' or session.username == 'ikki_y0518@icloud.com' %}
                <a href="/admin" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-2 rounded-lg text-sm transition-colors">
                    ğŸ“Š ç®¡ç†è€…ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
                </a>
                {% endif %}
            </div>
            <div class="flex items-center justify-center mb-4">
                <!-- Sunaãƒ­ã‚´ -->
                <div class="flex items-center relative mr-4">
                    <svg width="115" height="55" viewBox="0 0 115 55" class="flex-shrink-0">
                        <!-- å¤§ããªå††ï¼ˆå³ä¸Šã€æ˜ã‚‹ã„ã‚¿ãƒ¼ã‚³ã‚¤ã‚ºãƒ–ãƒ«ãƒ¼ï¼‰ -->
                        <circle cx="90" cy="20" r="13" fill="#67E8F9" opacity="0.85"/>
                        <!-- ä¸­ãã‚‰ã„ã®å††ï¼ˆå·¦ä¸­å¤®ã€æ¿ƒã„ãƒ–ãƒ«ãƒ¼ï¼‰ -->
                        <circle cx="73" cy="28" r="8" fill="#2563EB" opacity="0.9"/>
                        <!-- å°ã•ãªå††ï¼ˆå³ä¸‹ã€è–„ã„ã‚¿ãƒ¼ã‚³ã‚¤ã‚ºï¼‰ -->
                        <circle cx="83" cy="35" r="5" fill="#A7F3D0" opacity="0.75"/>
                        <!-- ãƒ†ã‚­ã‚¹ãƒˆ "suna" -->
                        <text x="0" y="42" font-size="26" font-weight="700" fill="#1E293B" font-family="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif" letter-spacing="-1.2px">
                            suna
                        </text>
                    </svg>
                </div>
                <div class="text-left">
                    <h1 class="text-3xl font-bold text-gray-800">Suna ToDo</h1>
                    <p class="text-lg text-gray-600">ã‚ãªãŸã®ä»Šæ—¥ã®å­¦ç¿’ã‚’è¿·ã‚ãšé€²ã‚ã‚ˆã†ï¼</p>
                </div>
            </div>
        </header>

        <!-- æ—¥ä»˜ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã¨è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
        <div class="flex items-center justify-between bg-white p-4 rounded-lg shadow-sm mb-6">
            <!-- å‰ã®æ—¥ã¸ç§»å‹•ãƒœã‚¿ãƒ³ -->
            <button id="prevDay" class="p-2 rounded-full hover:bg-gray-200 text-blue-600 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
            </button>
            <!-- ç¾åœ¨ã®æ—¥ä»˜ã¨æ›œæ—¥ã‚’è¡¨ç¤º -->
            <div class="flex flex-col items-center">
                <span id="currentDateDisplay" class="text-xl font-semibold text-gray-800"></span>
                <span id="dayOfWeekDisplay" class="text-sm text-gray-500"></span>
            </div>
            <!-- æ¬¡ã®æ—¥ã¸ç§»å‹•ãƒœã‚¿ãƒ³ -->
            <button id="nextDay" class="p-2 rounded-full hover:bg-gray-200 text-blue-600 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
            </button>
        </div>



        <!-- å®šå¸¸TODOãƒªã‚¹ãƒˆè¡¨ç¤ºã‚¨ãƒªã‚¢ -->
        <div class="mb-6">
            <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
                <span class="mr-2">ğŸ”„</span>
                å®šå¸¸TODO
            </h3>
            <ul id="routineTodoList" class="space-y-2">
                <!-- JavaScriptã«ã‚ˆã£ã¦å®šå¸¸TODOã‚¢ã‚¤ãƒ†ãƒ ãŒã“ã“ã«æŒ¿å…¥ã•ã‚Œã¾ã™ -->
            </ul>
        </div>

        <!-- æœ¬æ—¥ã®TODOãƒªã‚¹ãƒˆè¡¨ç¤ºã‚¨ãƒªã‚¢ -->
        <div class="mb-6">
            <h3 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
                <span class="mr-2">ğŸ“‹</span>
                æœ¬æ—¥ã®TODO
            </h3>
            <ul id="todayTodoList" class="space-y-2">
                <!-- JavaScriptã«ã‚ˆã£ã¦æœ¬æ—¥ã®TODOã‚¢ã‚¤ãƒ†ãƒ ãŒã“ã“ã«æŒ¿å…¥ã•ã‚Œã¾ã™ -->
            </ul>
        </div>

        <!-- å­¦ç¿’é€²æ—ã‚¨ãƒªã‚¢ -->
        <div class="bg-gradient-to-r from-blue-50 to-purple-50 p-4 rounded-lg mt-8">
            <h3 class="text-lg font-semibold text-gray-800 mb-2">ğŸ“Š ä»Šæ—¥ã®å­¦ç¿’é€²æ—</h3>
            <div class="flex items-center space-x-4">
                <div class="flex-1">
                    <div class="bg-gray-200 rounded-full h-3">
                        <div id="progressBar" class="bg-gradient-to-r from-blue-500 to-purple-500 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                </div>
                <span id="progressText" class="text-sm font-medium text-gray-700">0%</span>
            </div>
            <p class="text-sm text-gray-600 mt-2">å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯: <span id="completedCount">0</span> / <span id="totalCount">0</span></p>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢
        let dailyTasks = []; 
        let routineTasks = [];
        let currentDate = new Date();
        
        // é€£ç¶šEnterã‚­ãƒ¼è¿½è·¡ç”¨
        let lastEnterTime = {};
        const DOUBLE_ENTER_DELAY = 1000; // 1ç§’ä»¥å†…ã®é€£ç¶šEnterã§æ–°ã—ã„ã‚¿ã‚¹ã‚¯ä½œæˆ 

        // ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªIDã‚’ç”Ÿæˆã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function generateId() {
            return 'task_' + Math.random().toString(36).substr(2, 9);
        }

        // æ—¥ä»˜ã‚’æ—¥æœ¬èªã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function formatDate(date) {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('ja-JP', options);
        }

        // æ›œæ—¥ã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function getDayOfWeek(date) {
            const days = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
            return `(${days[date.getDay()]})`;
        }

        // APIã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’å–å¾—ã™ã‚‹é–¢æ•°
        async function loadTasks() {
            try {
                const dateStr = currentDate.toISOString().slice(0, 10);
                const response = await fetch(`/api/tasks/${dateStr}`);
                const data = await response.json();
                
                if (response.ok) {
                    dailyTasks = data.daily_tasks || [];
                    routineTasks = data.routine_tasks || [];
                    renderTasks();
                    updateProgress();
                } else {
                    console.error('Error loading tasks:', data.error);
                }
            } catch (error) {
                console.error('Error loading tasks:', error);
            }
        }

        // é€²æ—ãƒãƒ¼ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateProgress() {
            const allTasks = [...dailyTasks, ...routineTasks];
            const completedTasks = allTasks.filter(task => task.completed);
            const total = allTasks.length;
            const completed = completedTasks.length;
            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

            // å‰å›ã®é€²æ—ã‚’è¨˜éŒ²
            const previousPercentage = parseInt(document.getElementById('progressText').textContent) || 0;

            document.getElementById('progressBar').style.width = `${percentage}%`;
            document.getElementById('progressText').textContent = `${percentage}%`;
            document.getElementById('completedCount').textContent = completed;
            document.getElementById('totalCount').textContent = total;

            // 100%é”æˆæ™‚ã«ç´™å¹é›ªã‚’è¡¨ç¤ºï¼ˆå‰å›ãŒ100%æœªæº€ã®å ´åˆã®ã¿ï¼‰
            if (percentage === 100 && previousPercentage < 100 && total > 0) {
                createConfetti();
            }
        }

        // ç¾åœ¨ã®æ—¥ä»˜ã«åŸºã¥ã„ã¦ã‚¿ã‚¹ã‚¯ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹é–¢æ•°
        function renderTasks() {
            const routineList = document.getElementById('routineTodoList');
            const todayList = document.getElementById('todayTodoList');

            routineList.innerHTML = '';
            todayList.innerHTML = '';

            // å®šå¸¸TODOã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            routineTasks.forEach((task, index) => {
                const li = createTaskElement({
                    ...task,
                    type: 'routine'
                });
                routineList.appendChild(li);
            });

            // å®šå¸¸TODOã®è¦ªå­é–¢ä¿‚ã‚’é©ç”¨
            applyParentChildRelationships(routineList, routineTasks);

            // å®šå¸¸TODOãŒç©ºã®å ´åˆã€ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’è¿½åŠ ï¼ˆåˆå›ãƒ­ãƒ¼ãƒ‰æ™‚ã®ã¿ï¼‰
            if (routineTasks.length === 0 && !document.querySelector('.routine-placeholder-added')) {
                document.body.classList.add('routine-placeholder-added');
                addNewRoutineTask('');
            }

            // æœ¬æ—¥ã®TODOã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            const sortedDailyTasks = [...dailyTasks].sort((a, b) => {
                if (a.completed && !b.completed) return 1;
                if (!a.completed && b.completed) return -1;
                return (a.position || 0) - (b.position || 0);
            });

            sortedDailyTasks.forEach((task, index) => {
                const li = createTaskElement({
                    ...task,
                    type: 'daily'
                });
                todayList.appendChild(li);
            });

            // æœ¬æ—¥ã®TODOã®è¦ªå­é–¢ä¿‚ã‚’é©ç”¨
            applyParentChildRelationships(todayList, sortedDailyTasks);

            // æœ¬æ—¥ã®TODOãŒç©ºã®å ´åˆã€ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’è¿½åŠ ï¼ˆåˆå›ãƒ­ãƒ¼ãƒ‰æ™‚ã®ã¿ï¼‰
            if (dailyTasks.length === 0 && !document.querySelector('.daily-placeholder-added')) {
                document.body.classList.add('daily-placeholder-added');
                addNewTask('', true);
            }

            // æ—¥ä»˜è¡¨ç¤ºã‚’æ›´æ–°
            document.getElementById('currentDateDisplay').textContent = formatDate(currentDate);
            document.getElementById('dayOfWeekDisplay').textContent = getDayOfWeek(currentDate);
            
            updateProgress();
        }

        // è¦ªå­é–¢ä¿‚ã®CSSã‚¯ãƒ©ã‚¹ã‚’é©ç”¨ã™ã‚‹é–¢æ•°
        function applyParentChildRelationships(container, tasks) {
            const taskElements = container.querySelectorAll('.task-item');
            
            tasks.forEach((task, index) => {
                const element = taskElements[index];
                if (!element) return;

                const currentIndent = task.indent || 0;
                
                // å®Œäº†æ¸ˆã¿ã‚¿ã‚¹ã‚¯ã®ã‚¹ã‚¿ã‚¤ãƒ«é©ç”¨
                if (tasks[index].completed) {
                    element.classList.add('task-completed');
                } else {
                    element.classList.remove('task-completed');
                }
            });
        }


        // å€‹ã€…ã®ã‚¿ã‚¹ã‚¯è¦ç´ ï¼ˆ<li>ï¼‰ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createTaskElement(task) {
            const li = document.createElement('li');
            li.id = `task-${task.id}`;
            li.className = `task-item flex items-center py-3 px-2 transition duration-200 ease-in-out ${task.completed ? 'completed' : 'text-gray-800'} indent-${Math.min(task.indent || 0, 4)}`;
            li.draggable = task.type === 'daily';

            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ä½œæˆ
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = task.completed;
            checkbox.className = 'custom-checkbox';
            checkbox.addEventListener('change', () => toggleTaskCompleted(task.id, task.type));
            li.appendChild(checkbox);

            // ã‚¿ã‚¹ã‚¯ãƒ†ã‚­ã‚¹ãƒˆã®è¡¨ç¤º
            const taskTextSpan = document.createElement('span');
            taskTextSpan.textContent = task.text;
            taskTextSpan.contentEditable = 'true';
            taskTextSpan.className = `task-text flex-grow focus:outline-none focus:ring-0 ${task.completed ? 'line-through text-gray-500' : ''}`;
            taskTextSpan.setAttribute('role', 'textbox');

            if (task.type === 'daily') {
                taskTextSpan.addEventListener('blur', () => saveTaskText(task.id, taskTextSpan.textContent));
                taskTextSpan.addEventListener('keydown', async (e) => {
                    console.log('Daily task keydown:', e.key, 'for task:', task.id);
                    await handleTaskKeydown(e, task.id, taskTextSpan);
                });
            } else if (task.type === 'routine') {
                taskTextSpan.addEventListener('blur', () => saveRoutineTaskText(task.id, taskTextSpan.textContent));
                taskTextSpan.addEventListener('keydown', async (e) => {
                    console.log('Routine task keydown:', e.key, 'for task:', task.id);
                    await handleRoutineTaskKeydown(e, task.id, taskTextSpan);
                });
            }
            li.appendChild(taskTextSpan);

            // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆæ“ä½œãƒœã‚¿ãƒ³ã¯å‰Šé™¤ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªUIã«ã™ã‚‹ãŸã‚ï¼‰

            return li;
        }

        // ã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†
        async function handleTaskKeydown(e, taskId, textElement) {
            console.log('handleTaskKeydown called with key:', e.key);
            
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    // Shift+Enter: æ”¹è¡Œã‚’è¨±å¯
                    return; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ”¹è¡Œå‹•ä½œã‚’è¨±å¯
                } else {
                    // Enter: é€£ç¶šå…¥åŠ›ã§æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const currentTime = Date.now();
                    const lastTime = lastEnterTime[taskId] || 0;
                    
                    if (currentTime - lastTime < DOUBLE_ENTER_DELAY) {
                        // 2å›ç›®ã®Enter: æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
                        console.log('Double Enter detected: creating new task');
                        
                        // ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜ã—ã¦ã‹ã‚‰æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
                        await saveTaskText(taskId, textElement.textContent);
                        
                        const currentIndex = dailyTasks.findIndex(t => t.id === taskId);
                        const task = dailyTasks[currentIndex];
                        if (task && currentIndex !== -1) {
                            await addNewTask('', false, task.indent || 0);
                        }
                        
                        // ãƒªã‚»ãƒƒãƒˆ
                        delete lastEnterTime[taskId];
                    } else {
                        // 1å›ç›®ã®Enter: ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†ã‚’ç¢ºå®š
                        console.log('First Enter detected: saving text');
                        
                        // ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜
                        await saveTaskText(taskId, textElement.textContent);
                        
                        // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç¶­æŒ
                        textElement.blur();
                        setTimeout(() => {
                            textElement.focus();
                        }, 10);
                        
                        // æ™‚é–“ã‚’è¨˜éŒ²
                        lastEnterTime[taskId] = currentTime;
                    }
                }
            } else if (e.key === 'Tab') {
                // ToDoã‚¢ãƒ—ãƒªå†…ã§ã¯å¸¸ã«Tabã‚­ãƒ¼ï¼ˆShift+Tabå«ã‚€ï¼‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç§»å‹•ï¼‰ã‚’ç„¡åŠ¹åŒ–
                e.preventDefault();
                e.stopPropagation();
                
                const task = dailyTasks.find(t => t.id === taskId);
                if (task) {
                    const currentIndent = task.indent || 0;
                    const newIndent = e.shiftKey
                        ? Math.max(0, currentIndent - 1)
                        : Math.min(4, currentIndent + 1);
                    
                    console.log(`Daily task indent: ${currentIndent} â†’ ${newIndent}`);
                    
                    // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆå®Ÿè¡Œï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
                    try {
                        await updateTaskIndent(taskId, newIndent);
                        
                        // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¾©å…ƒ
                        setTimeout(() => {
                            const taskSpan = document.querySelector(`#task-${taskId} .task-text`);
                            if (taskSpan) {
                                taskSpan.focus();
                                // ã‚«ãƒ¼ã‚½ãƒ«ã‚’æœ«å°¾ã«ç§»å‹•
                                const range = document.createRange();
                                range.selectNodeContents(taskSpan);
                                range.collapse(false);
                                const sel = window.getSelection();
                                sel.removeAllRanges();
                                sel.addRange(range);
                            }
                        }, 100);
                    } catch (error) {
                        console.error('Error in updateTaskIndent:', error);
                    }
                }
            } else if (e.key === 'Backspace' && textElement.textContent.trim() === '') {
                // ç©ºã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¦å‰ã®ã‚¿ã‚¹ã‚¯ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                e.preventDefault();
                focusPreviousTask(taskId);
                deleteTask(taskId);
            }
        }

        // å‰ã®ã‚¿ã‚¹ã‚¯ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç§»å‹•
        function focusPreviousTask(currentTaskId) {
            const currentIndex = dailyTasks.findIndex(t => t.id === currentTaskId);
            if (currentIndex > 0) {
                const previousTask = dailyTasks[currentIndex - 1];
                setTimeout(() => {
                    const previousSpan = document.querySelector(`#task-${previousTask.id} .task-text`);
                    if (previousSpan) {
                        previousSpan.focus();
                        // ã‚«ãƒ¼ã‚½ãƒ«ã‚’æœ«å°¾ã«ç§»å‹•
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.selectNodeContents(previousSpan);
                        range.collapse(false);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }, 50);
            }
        }

        // ã‚¿ã‚¹ã‚¯ã®å®Œäº†çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆ
        async function toggleTaskCompleted(taskId, type) {
            try {
                if (type === 'daily') {
                    const task = dailyTasks.find(t => t.id === taskId);
                    if (task) {
                        const response = await fetch(`/api/tasks/${taskId}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ completed: !task.completed })
                        });
                        
                        if (response.ok) {
                            task.completed = !task.completed;
                            renderTasks();
                        }
                    }
                } else if (type === 'routine') {
                    const response = await fetch('/api/routine/toggle', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            routine_id: taskId,
                            date: currentDate.toISOString().slice(0, 10)
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const task = routineTasks.find(t => t.id === taskId);
                        if (task) {
                            task.completed = data.completed;
                            renderTasks();
                        }
                    }
                }
            } catch (error) {
                console.error('Error toggling task:', error);
            }
        }

        // ã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜
        async function saveTaskText(taskId, text) {
            try {
                const trimmedText = text.trim();
                const task = dailyTasks.find(t => t.id === taskId);
                
                if (!task) return;
                
                // ç©ºã®ã‚¿ã‚¹ã‚¯ã®è‡ªå‹•å‰Šé™¤ã‚’ç„¡åŠ¹åŒ–ï¼ˆæ‰‹å‹•å‰Šé™¤ã®ã¿ï¼‰
                if (trimmedText !== task.text) {
                    const response = await fetch(`/api/tasks/${taskId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: trimmedText })
                    });
                    
                    if (response.ok) {
                        task.text = trimmedText;
                        updateProgress(); // å€‹åˆ¥ã«é€²æ—æ›´æ–°
                    }
                }
            } catch (error) {
                console.error('Error saving task text:', error);
            }
        }

        // æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
        async function addNewTask(text = '', isPlaceholder = false, indent = 0) {
            try {
                const taskId = generateId();
                const dateStr = currentDate.toISOString().slice(0, 10);
                
                const response = await fetch('/api/tasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: taskId,
                        text: text,
                        date: dateStr,
                        indent: indent
                    })
                });
                
                if (response.ok) {
                    dailyTasks.push({
                        id: taskId,
                        text: text,
                        completed: false,
                        date: dateStr,
                        indent: indent,
                        position: dailyTasks.length
                    });
                    
                    renderTasks();
                    
                    // æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                    setTimeout(() => {
                        const newSpan = document.querySelector(`#task-${taskId} .task-text`);
                        if (newSpan) {
                            newSpan.focus();
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('Error adding task:', error);
            }
        }

        // æŒ‡å®šã—ãŸä½ç½®ã«æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
        async function addNewTaskAtPosition(text = '', isPlaceholder = false, indent = 0, insertIndex = 0) {
            try {
                const taskId = generateId();
                const dateStr = currentDate.toISOString().slice(0, 10);
                
                const response = await fetch('/api/tasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: taskId,
                        text: text,
                        date: dateStr,
                        indent: indent
                    })
                });
                
                if (response.ok) {
                    // æŒ‡å®šã—ãŸä½ç½®ã«ã‚¿ã‚¹ã‚¯ã‚’æŒ¿å…¥
                    const newTask = {
                        id: taskId,
                        text: text,
                        completed: false,
                        date: dateStr,
                        indent: indent,
                        position: insertIndex
                    };
                    
                    // æŒ¿å…¥ä½ç½®ã‚ˆã‚Šå¾Œã®ã‚¿ã‚¹ã‚¯ã®positionã‚’æ›´æ–°
                    dailyTasks.forEach(task => {
                        if (task.position >= insertIndex) {
                            task.position += 1;
                        }
                    });
                    
                    // æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’æŒ¿å…¥
                    dailyTasks.splice(insertIndex, 0, newTask);
                    
                    renderTasks();
                    
                    // æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                    setTimeout(() => {
                        const newSpan = document.querySelector(`#task-${taskId} .task-text`);
                        if (newSpan) {
                            newSpan.focus();
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('Error adding task at position:', error);
            }
        }

        // å®šå¸¸ã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†
        async function handleRoutineTaskKeydown(e, taskId, textElement) {
            console.log('handleRoutineTaskKeydown called with key:', e.key);
            
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    // Shift+Enter: æ”¹è¡Œã‚’è¨±å¯
                    return; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ”¹è¡Œå‹•ä½œã‚’è¨±å¯
                } else {
                    // Enter: é€£ç¶šå…¥åŠ›ã§æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const currentTime = Date.now();
                    const lastTime = lastEnterTime[taskId] || 0;
                    
                    if (currentTime - lastTime < DOUBLE_ENTER_DELAY) {
                        // 2å›ç›®ã®Enter: æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
                        console.log('Double Enter detected: creating new routine task');
                        
                        // ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜ã—ã¦ã‹ã‚‰æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
                        await saveRoutineTaskText(taskId, textElement.textContent);
                        
                        const currentIndex = routineTasks.findIndex(t => t.id === taskId);
                        const task = routineTasks[currentIndex];
                        if (task && currentIndex !== -1) {
                            await addNewRoutineTask('', task.indent || 0);
                        }
                        
                        // ãƒªã‚»ãƒƒãƒˆ
                        delete lastEnterTime[taskId];
                    } else {
                        // 1å›ç›®ã®Enter: ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†ã‚’ç¢ºå®š
                        console.log('First Enter detected: saving routine task text');
                        
                        // ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜
                        await saveRoutineTaskText(taskId, textElement.textContent);
                        
                        // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç¶­æŒ
                        textElement.blur();
                        setTimeout(() => {
                            textElement.focus();
                        }, 10);
                        
                        // æ™‚é–“ã‚’è¨˜éŒ²
                        lastEnterTime[taskId] = currentTime;
                    }
                }
            } else if (e.key === 'Tab') {
                // ToDoã‚¢ãƒ—ãƒªå†…ã§ã¯å¸¸ã«Tabã‚­ãƒ¼ï¼ˆShift+Tabå«ã‚€ï¼‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç§»å‹•ï¼‰ã‚’ç„¡åŠ¹åŒ–
                e.preventDefault();
                e.stopPropagation();
                
                const task = routineTasks.find(t => t.id === taskId);
                if (task) {
                    const currentIndent = task.indent || 0;
                    const newIndent = e.shiftKey
                        ? Math.max(0, currentIndent - 1)
                        : Math.min(4, currentIndent + 1);
                    
                    console.log(`Routine task indent: ${currentIndent} â†’ ${newIndent}`);
                    
                    // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆå®Ÿè¡Œï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
                    try {
                        await updateRoutineTaskIndent(taskId, newIndent);
                        
                        // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¾©å…ƒ
                        setTimeout(() => {
                            const taskSpan = document.querySelector(`#task-${taskId} .task-text`);
                            if (taskSpan) {
                                taskSpan.focus();
                                // ã‚«ãƒ¼ã‚½ãƒ«ã‚’æœ«å°¾ã«ç§»å‹•
                                const range = document.createRange();
                                range.selectNodeContents(taskSpan);
                                range.collapse(false);
                                const sel = window.getSelection();
                                sel.removeAllRanges();
                                sel.addRange(range);
                            }
                        }, 100);
                    } catch (error) {
                        console.error('Error in updateRoutineTaskIndent:', error);
                    }
                }
            } else if (e.key === 'Backspace' && textElement.textContent.trim() === '') {
                // ç©ºã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¦å‰ã®ã‚¿ã‚¹ã‚¯ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                e.preventDefault();
                focusPreviousRoutineTask(taskId);
                deleteRoutineTask(taskId);
            }
        }

        // å‰ã®å®šå¸¸ã‚¿ã‚¹ã‚¯ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç§»å‹•
        function focusPreviousRoutineTask(currentTaskId) {
            const currentIndex = routineTasks.findIndex(t => t.id === currentTaskId);
            if (currentIndex > 0) {
                const previousTask = routineTasks[currentIndex - 1];
                setTimeout(() => {
                    const previousSpan = document.querySelector(`#task-${previousTask.id} .task-text`);
                    if (previousSpan) {
                        previousSpan.focus();
                        // ã‚«ãƒ¼ã‚½ãƒ«ã‚’æœ«å°¾ã«ç§»å‹•
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.selectNodeContents(previousSpan);
                        range.collapse(false);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }, 50);
            }
        }

        // å®šå¸¸ã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜
        async function saveRoutineTaskText(taskId, text) {
            try {
                const trimmedText = text.trim();
                const task = routineTasks.find(t => t.id === taskId);
                
                if (!task) return;
                
                // ç©ºã®ã‚¿ã‚¹ã‚¯ã®è‡ªå‹•å‰Šé™¤ã‚’ç„¡åŠ¹åŒ–ï¼ˆæ‰‹å‹•å‰Šé™¤ã®ã¿ï¼‰
                if (trimmedText !== task.text) {
                    const response = await fetch(`/api/routine/${taskId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: trimmedText })
                    });
                    
                    if (response.ok) {
                        task.text = trimmedText;
                        updateProgress(); // å€‹åˆ¥ã«é€²æ—æ›´æ–°
                    }
                }
            } catch (error) {
                console.error('Error saving routine task text:', error);
            }
        }

        // æ–°ã—ã„å®šå¸¸ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
        async function addNewRoutineTask(text = '', indent = 0) {
            try {
                const taskId = generateId();
                
                const response = await fetch('/api/routine', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: taskId,
                        text: text,
                        indent: indent
                    })
                });
                
                if (response.ok) {
                    routineTasks.push({
                        id: taskId,
                        text: text,
                        indent: indent,
                        position: routineTasks.length
                    });
                    
                    renderTasks();
                    
                    // æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                    setTimeout(() => {
                        const newSpan = document.querySelector(`#task-${taskId} .task-text`);
                        if (newSpan) {
                            newSpan.focus();
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('Error adding routine task:', error);
            }
        }

        // æŒ‡å®šã—ãŸä½ç½®ã«æ–°ã—ã„å®šå¸¸ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
        async function addNewRoutineTaskAtPosition(text = '', indent = 0, insertIndex = 0) {
            try {
                const taskId = generateId();
                
                const response = await fetch('/api/routine', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: taskId,
                        text: text,
                        indent: indent
                    })
                });
                
                if (response.ok) {
                    // æŒ‡å®šã—ãŸä½ç½®ã«ã‚¿ã‚¹ã‚¯ã‚’æŒ¿å…¥
                    const newTask = {
                        id: taskId,
                        text: text,
                        indent: indent,
                        position: insertIndex
                    };
                    
                    // æŒ¿å…¥ä½ç½®ã‚ˆã‚Šå¾Œã®ã‚¿ã‚¹ã‚¯ã®positionã‚’æ›´æ–°
                    routineTasks.forEach(task => {
                        if (task.position >= insertIndex) {
                            task.position += 1;
                        }
                    });
                    
                    // æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’æŒ¿å…¥
                    routineTasks.splice(insertIndex, 0, newTask);
                    
                    renderTasks();
                    
                    // æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                    setTimeout(() => {
                        const newSpan = document.querySelector(`#task-${taskId} .task-text`);
                        if (newSpan) {
                            newSpan.focus();
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('Error adding routine task at position:', error);
            }
        }

        // ç´™å¹é›ªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function createConfetti() {
            const confettiContainer = document.createElement('div');
            confettiContainer.id = 'confetti-container';
            confettiContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                pointer-events: none;
                z-index: 9999;
            `;
            document.body.appendChild(confettiContainer);

            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8'];
            
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.style.cssText = `
                    position: absolute;
                    width: 10px;
                    height: 10px;
                    background-color: ${colors[Math.floor(Math.random() * colors.length)]};
                    top: -10px;
                    left: ${Math.random() * 100}vw;
                    animation: confetti-fall 3s linear forwards;
                    transform: rotate(${Math.random() * 360}deg);
                `;
                confettiContainer.appendChild(confetti);
            }

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã«ã‚³ãƒ³ãƒ†ãƒŠã‚’å‰Šé™¤
            setTimeout(() => {
                document.body.removeChild(confettiContainer);
            }, 3000);
        }

        // å®šå¸¸ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤
        async function deleteRoutineTask(taskId) {
            try {
                const response = await fetch(`/api/routine/${taskId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    routineTasks = routineTasks.filter(t => t.id !== taskId);
                    
                    // æœ€å¾Œã®ã‚¿ã‚¹ã‚¯ãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆã€æ–°ã—ã„ç©ºã®ã‚¿ã‚¹ã‚¯ã‚’è‡ªå‹•ä½œæˆ
                    if (routineTasks.length === 0) {
                        await addNewRoutineTask('');
                    } else {
                        renderTasks();
                    }
                }
            } catch (error) {
                console.error('Error deleting routine task:', error);
            }
        }

        // ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤
        async function deleteTask(taskId) {
            try {
                const response = await fetch(`/api/tasks/${taskId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    dailyTasks = dailyTasks.filter(t => t.id !== taskId);
                    
                    // æœ€å¾Œã®ã‚¿ã‚¹ã‚¯ãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆã€æ–°ã—ã„ç©ºã®ã‚¿ã‚¹ã‚¯ã‚’è‡ªå‹•ä½œæˆ
                    if (dailyTasks.length === 0) {
                        await addNewTask('', false, 0);
                    } else {
                        renderTasks();
                    }
                }
            } catch (error) {
                console.error('Error deleting task:', error);
            }
        }

        // ã‚¿ã‚¹ã‚¯ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æ›´æ–°ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç¶­æŒå¼·åŒ–ç‰ˆï¼‰
        async function updateTaskIndentWithFocus(taskId, newIndent, originalText, originalCursorPos) {
            try {
                const response = await fetch(`/api/tasks/${taskId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ indent: newIndent })
                });
                
                if (response.ok) {
                    const task = dailyTasks.find(t => t.id === taskId);
                    if (task) {
                        task.indent = newIndent;
                        console.log('Updated daily task indent to:', newIndent);
                        
                        // UIæ›´æ–°å‰ã«ç¾åœ¨ã®ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¦ç´ ã‚’è¨˜éŒ²
                        const currentActiveElement = document.activeElement;
                        const wasTaskFocused = currentActiveElement && currentActiveElement.classList.contains('task-text');
                        
                        // UIæ›´æ–°
                        renderTasks();
                        
                        // éå¸¸ã«çŸ­ã„é…å»¶ã§ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¾©å…ƒï¼ˆã‚ˆã‚Šç¢ºå®Ÿï¼‰
                        setTimeout(() => {
                            restoreTaskFocus(taskId, originalText, originalCursorPos);
                        }, 10);
                        
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å°‘ã—é•·ã„é…å»¶ã§ã‚‚è©¦è¡Œ
                        setTimeout(() => {
                            const taskSpan = document.querySelector(`#task-${taskId} .task-text`);
                            if (taskSpan && document.activeElement !== taskSpan) {
                                console.log('Fallback focus restoration for daily task:', taskId);
                                restoreTaskFocus(taskId, originalText, originalCursorPos);
                            }
                        }, 100);
                    }
                }
            } catch (error) {
                console.error('Error updating task indent:', error);
            }
        }

        // ã‚¿ã‚¹ã‚¯ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æ›´æ–°ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
        async function updateTaskIndent(taskId, newIndent) {
            try {
                const response = await fetch(`/api/tasks/${taskId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ indent: newIndent })
                });
                
                if (response.ok) {
                    const task = dailyTasks.find(t => t.id === taskId);
                    if (task) {
                        task.indent = newIndent;
                        renderTasks();
                    }
                }
            } catch (error) {
                console.error('Error updating task indent:', error);
            }
        }

        // å®šå¸¸ã‚¿ã‚¹ã‚¯ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æ›´æ–°ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç¶­æŒå¼·åŒ–ç‰ˆï¼‰
        async function updateRoutineTaskIndentWithFocus(taskId, newIndent, originalText, originalCursorPos) {
            try {
                const response = await fetch(`/api/routine/${taskId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ indent: newIndent })
                });
                
                if (response.ok) {
                    const task = routineTasks.find(t => t.id === taskId);
                    if (task) {
                        task.indent = newIndent;
                        console.log('Updated routine task indent to:', newIndent);
                        
                        // UIæ›´æ–°å‰ã«ç¾åœ¨ã®ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¦ç´ ã‚’è¨˜éŒ²
                        const currentActiveElement = document.activeElement;
                        const wasTaskFocused = currentActiveElement && currentActiveElement.classList.contains('task-text');
                        
                        // UIæ›´æ–°
                        renderTasks();
                        
                        // éå¸¸ã«çŸ­ã„é…å»¶ã§ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¾©å…ƒï¼ˆã‚ˆã‚Šç¢ºå®Ÿï¼‰
                        setTimeout(() => {
                            restoreTaskFocus(taskId, originalText, originalCursorPos);
                        }, 10);
                        
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å°‘ã—é•·ã„é…å»¶ã§ã‚‚è©¦è¡Œ
                        setTimeout(() => {
                            const taskSpan = document.querySelector(`#task-${taskId} .task-text`);
                            if (taskSpan && document.activeElement !== taskSpan) {
                                console.log('Fallback focus restoration for routine task:', taskId);
                                restoreTaskFocus(taskId, originalText, originalCursorPos);
                            }
                        }, 100);
                    }
                }
            } catch (error) {
                console.error('Error updating routine task indent:', error);
            }
        }

        // å®šå¸¸ã‚¿ã‚¹ã‚¯ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æ›´æ–°ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
        async function updateRoutineTaskIndent(taskId, newIndent) {
            try {
                const response = await fetch(`/api/routine/${taskId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ indent: newIndent })
                });
                
                if (response.ok) {
                    const task = routineTasks.find(t => t.id === taskId);
                    if (task) {
                        task.indent = newIndent;
                        renderTasks();
                    }
                }
            } catch (error) {
                console.error('Error updating routine task indent:', error);
            }
        }

        // å…±é€šã®ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¾©å…ƒé–¢æ•°
        function restoreTaskFocus(taskId, originalText, originalCursorPos) {
            try {
                const taskSpan = document.querySelector(`#task-${taskId} .task-text`);
                if (!taskSpan) {
                    console.log('Task span not found for focus restoration:', taskId);
                    return false;
                }

                // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¨­å®š
                taskSpan.focus();
                
                // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’å¾©å…ƒ
                try {
                    const textContent = taskSpan.textContent || '';
                    const maxOffset = textContent.length;
                    const safeOffset = Math.min(originalCursorPos, maxOffset);
                    
                    // ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ã‚’å–å¾—ã¾ãŸã¯ä½œæˆ
                    let textNode = taskSpan.firstChild;
                    if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
                        if (textContent.length > 0) {
                            textNode = taskSpan.childNodes[0];
                        } else {
                            // ç©ºã®ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
                            textNode = document.createTextNode('');
                            taskSpan.appendChild(textNode);
                        }
                    }
                    
                    if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                        const range = document.createRange();
                        range.setStart(textNode, safeOffset);
                        range.setEnd(textNode, safeOffset);
                        
                        const sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                        
                        console.log(`Task focus restored: ${taskId}, position: ${safeOffset}/${maxOffset}`);
                        return true;
                    } else {
                        // ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                        const range = document.createRange();
                        range.selectNodeContents(taskSpan);
                        range.collapse(false);
                        
                        const sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                        
                        console.log(`Task focus restored (fallback): ${taskId}`);
                        return true;
                    }
                } catch (e) {
                    console.log('Failed to restore cursor position:', e);
                    // æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚«ãƒ¼ã‚½ãƒ«ã‚’æœ«å°¾ã«è¨­å®š
                    try {
                        const range = document.createRange();
                        range.selectNodeContents(taskSpan);
                        range.collapse(false);
                        
                        const sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                        
                        console.log(`Task focus restored (final fallback): ${taskId}`);
                        return true;
                    } catch (e2) {
                        console.log('Complete focus restoration failure:', e2);
                        return false;
                    }
                }
            } catch (error) {
                console.error('Error in restoreTaskFocus:', error);
                return false;
            }
        }

        // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.addEventListener('DOMContentLoaded', () => {
            loadTasks();

            // æ—¥ä»˜å¤‰æ›´ãƒœã‚¿ãƒ³
            document.getElementById('prevDay').addEventListener('click', () => {
                currentDate.setDate(currentDate.getDate() - 1);
                loadTasks();
            });

            document.getElementById('nextDay').addEventListener('click', () => {
                const tomorrow = new Date(currentDate);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const today = new Date();
                
                // æ—¥ä»˜ã®ã¿ã§æ¯”è¼ƒã—ã¦ã€ä»Šæ—¥ã¾ã§ï¼ˆä»Šæ—¥ã‚’å«ã‚€ï¼‰é€²ã‚ã‚‹ã‚ˆã†ã«ã™ã‚‹
                const tomorrowDateStr = tomorrow.toISOString().slice(0, 10);
                const todayDateStr = today.toISOString().slice(0, 10);
                
                if (tomorrowDateStr <= todayDateStr) {
                    currentDate.setDate(currentDate.getDate() + 1);
                    loadTasks();
                }
            });

            // ãƒ˜ãƒ«ãƒ—ã®è¡¨ç¤º/éè¡¨ç¤ºãƒœã‚¿ãƒ³
            document.getElementById('toggleHelp').addEventListener('click', () => {
                const helpContent = document.getElementById('helpContent');
                helpContent.classList.toggle('hidden');
            });

            // ToDoã‚¢ãƒ—ãƒªå…¨ä½“ã§Tab/Shift+Tabã‚­ãƒ¼ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’ç„¡åŠ¹åŒ–
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    // å¸¸ã«Tabã‚­ãƒ¼ï¼ˆShift+Tabå«ã‚€ï¼‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’ç„¡åŠ¹åŒ–
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // ã‚¿ã‚¹ã‚¯ãƒ†ã‚­ã‚¹ãƒˆå†…ã®å ´åˆã¯ã€å„ã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã§å‡¦ç†ã•ã‚Œã‚‹
                    // ã‚¿ã‚¹ã‚¯ãƒ†ã‚­ã‚¹ãƒˆå¤–ã®å ´åˆã¯ã€ä½•ã‚‚ã—ãªã„ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç§»å‹•ã‚’å®Œå…¨ã«ç„¡åŠ¹åŒ–ï¼‰
                    console.log('Global Tab key intercepted:', e.shiftKey ? 'Shift+Tab' : 'Tab');
                }
            }, true); // ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ•ã‚§ãƒ¼ã‚ºã§å‡¦ç†

            // å®šå¸¸ã‚¿ã‚¹ã‚¯è¿½åŠ ãƒœã‚¿ãƒ³ã¯å‰Šé™¤æ¸ˆã¿
        });
    </script>
</body>
</html> 